<!DOCTYPE HTML>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
    <link href='http://fonts.googleapis.com/css?family=Lato|Lora' rel='stylesheet' type='text/css'>
    <title>Jeremy McIntyre | Things I learned</title>
  </head>

  <body>
    <div class="banner">
      <nav>
        <ul>
          <li><a href="http://jeremymcintyre.github.io/blog/index.html">HOME</a></li>
          <li><a href="http://jeremymcintyre.github.io/blog/blog-index.html">BLOG</a></li>
          <li><a href="http://jeremymcintyre.github.io/blog/projects.html">PROJECTS</a></li>
          <li><a href="http://jeremymcintyre.github.io/blog/index.html#about">ABOUT</a></li>
          <li><a href="http://jeremymcintyre.github.io/blog/index.html#contact">CONTACT</a></li>
        </ul>
      </nav>

      <header>
        <h1>Things I learned while chasing dreams conceived in this lovely backdrop</h1>
      </header>
    </div>
    <article>
      <h2>Intro to Ruby classes and instance methods</h2>
      <div class="serif">
        <h3>6 Nov 2014</h3>
        <hr>

        <p>This week at Dev Bootcamp we started playing with Ruby classes. This is very exciting, and I'll tell you why:</p>

        <p>Classes are an exceptionally vital part of Ruby as an object-oriented language. Just like in the real-world, almost everything in Ruby is an object -- it has certain traits or abilities, and can be classified according to what it is and how it behaves. In fact, every object in Ruby is an instance of a class. This makes it super useful for modeling real-world things, because it means we can organize objects and their abilities according to how they are organized in real life.</p>

        <p>For example, a Northern Harrier is a hawk, which is a bird, which is a type of animal. Since all animals share certain traits, we could make a Ruby class called Animal to organize these universal attributes. All birds are animals, so class Bird could avoid redundancy by inheriting from class Animal and additionally housing traits unique to birds. Class Hawk could inherit from class Bird, etc.</p>

        <img src="./imgs/northern-harrier.jpg" alt="original source is http://birds.audubon.org/sites/default/files/imagecache/bird-full/species_images/Northern_Harrier_l07-46-093_l.jpg">

        <p>Why is this helpful to us? Well, every time we want to represent another Northern Harrier, it saves us the trouble of hardcoding all of the traits and abilities of the hawk in a procedural way. Instead, we can simply initialize a new instance of class NorthernHarrier, and it is instantiated into existence as an object with all the unique features of a NorthernHarrier, as well as the inherited traits from the classes Hawk, Bird, and Animal.</p>

        <p>What if we want to model something intangible, like the sky? Well, the sky has traits and abilities, in a sense. It can be light or dark, have unique sunrises and sunsets, feature different weather systems; it could be classified as something like "PlanetView," or "PlanetaryPerspective" or some other better class than I can think of. The bottom line is that because we can describe it, we can model it in Ruby using classes!</p>

        <p>Now let's take a look at a class I created to demonstrate some ideas about classes and their components:</p>

        <pre><code class="ruby">class Guitar

  def initialize(brand, model)
    @brand = brand
    @model = model
    @new_strings = true
    @brand_of_strings = "not specified"
    puts "Nice! That is a beautiful #{brand} #{model}."
  end

  def brand
    @brand
  end

  def model
    @model
  end

  def brand_of_strings
    puts "You have #{@brand_of_strings} strings."
  end

  def brand_of_strings=(company_name)
    @brand_of_strings = company_name
  end

  def play_a_lot
    @new_strings = false
    puts "You played every day for 6 months! Those strings sound pretty dull."
  end

  def change_strings?
    if @new_strings == false
      puts "Good call; they were old! They've been replaced with new ones."
      @new_strings = true
    elsif @new_strings == true
      puts "You don't need to change them yet. They're still new!"
    end
  end

end</code></pre>
        <p>In my Guitar class, we have an initialize method that gets called every time we create a new instance of the class (a new guitar). So let's create a new instance of class Guitar and store it in the variable <code>my_guitar</code>.</p>
        <pre><code>my_guitar = Guitar.new("Gibston","J-45")

Nice! That is a beautiful Gibston J-45.
  => @brand="Gibson", @model="J-45", @new_strings=true,
  @brand_of_strings="not specified"</code></pre>

        <p>When the guitar (new object) was created, its instance variables (starting with @ signs) were initialized so that <code>@brand = "Gibson", @model = "J-45", @new_strings = true</code>, and <code>@brand_of_strings = "not specified"</code>. Note that we also defined a series of methods that repeat back those values. For instance, the method <code>brand</code> returns the stored value of the instance variable <code>@brand</code>. This is a reader method; it reads the instance variable back to us.</p>

        <pre><code>def brand
  @brand
end

my_guitar.brand
=> "Gibson"</code></pre>

        <p>For <code>@brand_of_strings</code>, we have both a reader and a writer method. The reader method tells us what brand of strings we have, while the writer method <code>brand_of_strings=(company_name)</code> allows us to assign what company makes the strings. This makes sense, because strings are impermanent and we might decide we want to start using a different brand of strings with our real guitar. On the other hand, we do not have writer methods for the <code>brand</code> or <code>model</code>, because once a guitar is made, it's brand and model type do not change! We want our Ruby class model to reflect this reality, so we do not make them writeable.</p>

        <p>Now, because reader and writer methods are so common in Ruby classes, there is a shorter way to make them! The <code>attr_reader</code> designates methods to read instance variables by name; <code>attr_writer</code> creates writer methods, and <code>attr_accessor</code> combines both to make reader and writer methods. If we refactor my class with appropriate <code>attr_</code> methods, it gets a lot shorter:</p>

        <pre><code>class Guitar

  attr_reader :brand, :model, :new_strings
  attr_accessor :brand_of_strings

  def initialize(brand, model)
    @brand = brand
    @model = model
    @new_strings = true
    @brand_of_strings = "not specified"
    puts "Nice! That is a beautiful #{brand} #{model}."
  end

  def play_a_lot
    @new_strings = false
    puts "You played every day for 6 months! Those strings sound pretty dull."
  end

  def change_strings?
    if @new_strings == false
      puts "Good call; they were old! They've been replaced with new ones."
      @new_strings = true
    elsif @new_strings == true
      puts "You don't need to change them yet. They're still new!"
    end
  end

end</code></pre>
        <p>After refactoring, if we refer to our object <code>my_guitar</code> and call <code>my_guitar.new_strings</code> it will return <code>true.</code> Notice we do not specify a method <code>new_strings</code> except through the <code>attr_reader</code>. Likewise, if we call <code>my_guitar.brand_of_strings = "Martin"</code> it will set the brand of strings to <code>"Martin"</code> using the <code>attr_accessor</code>. Then, if we call <code>my_guitar.brand_of_strings</code> it will read <code>"Martin"</code> back to us.</p>

        <p>This is all well and good. However, what if we want to make methods that aren't accessible from outside of the class? What if we only want them to be called by other methods within the class? This idea is called encapsulation, or controlling the visibility and accessibility of different parts of code.</p>

        <p>All of our methods are public by default -- all of them can be called on our instance <code>my_guitar</code> from outside the method. However, if we want to make a method private, we can do so by specifying <code>private</code>. This means that it can only be called implicitly (on the implied instance of the class), because it is:</p>
        <ol>
          <li>instance-specific, and</li>
          <li>private to the methods of the object.</li>
        </ol>
        <p>Essentially, we can never specify the receiver of a private method (unless it is a writer, but let's not worry about that.) So, a private method would be something that operates on <code>my_guitar</code> but only within methods that belong to <code>my_guitar</code>. We'll look at this below, and then finish up! (To avoid repetition, only new parts of our class will be shown.)</p>

        <pre><code>class Guitar

  attr_reader :in_tune

  def initialize
    @in_tune = true
  end

  def play_hard
    detune
    puts "You played really hard and now some of your strings sound out of tune."
  end

  private
  # methods below this are private.

  def detune
    @in_tune = false
  end

  public
  # cancels the private. methods below this are public.

  def tune
    @in_tune = true
    puts "Good to go! Your strings are in tune."
  end

end</code></pre>
        <p>We would not want to ever intentionally detune our guitar, so we have made it a private method that represents what happens when we <code>play_hard</code>. It is impossible to call it from outside of the class, since <code>my_guitar.detune</code> will raise an error informing us that we are calling a private method. So, when we initialize <code>my_guitar</code> in our updated class, it is given an instance variable that tells us it is <code>in_tune</code>, but if we play our guitar really hard, the strings get out of tune by way of the private method. At that point, we can retune our guitar using <code>tune</code>, made public because it appears below <code>public</code>.</p>

        <p>Pretty neat, huh? This is just a small taste of all the creative ways in which Ruby allows us to model real-world objects using classes.</p>

        <p>Thanks for reading!</p>
        <a href="http://jeremymcintyre.github.io/blog/blog-index.html">back</a>
      </div>
    </article>

    <footer>
      <a href="https://plus.google.com/u/0/113788165639624262148/posts"><img src="https://raw.githubusercontent.com/jeremymcintyre/jeremymcintyre.github.io/master/blog/imgs/google-plus-32.png" alt=""></a>
      <a href="https://www.linkedin.com/in/jeremymcintyre"><img src="https://raw.githubusercontent.com/jeremymcintyre/jeremymcintyre.github.io/master/blog/imgs/linkedin-32.png" alt=""></a>
      <a href="https://twitter.com/alt_jmac"><img src="https://raw.githubusercontent.com/jeremymcintyre/jeremymcintyre.github.io/master/blog/imgs/twitter-32.png" alt=""></a>
      <a href="https://github.com/jeremymcintyre"><img src="https://raw.githubusercontent.com/jeremymcintyre/jeremymcintyre.github.io/master/blog/imgs/github-32.png" alt=""></a>
    </footer>


  </body>


</html>